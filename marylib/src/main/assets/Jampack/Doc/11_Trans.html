<html>
<head>
    <title> The Jampack Owners Manual: Transformations</title>
</head>

<body bgcolor=white>
<h2> Transformations </h2>

<p>Back to:
    <a href="00_Manual.html#mancont"> Main contents</a>.

<h3> Contents </h3>
<dl>
    <dt><a href="#house"> Householder Transformations
        (The House suite) </a>
    <dt><a href="#pivot"> Pivoting (the Pivot suite)</a>
    <dt><a href="#rot"> Plane rotations (the Rot suite) </a>
    <dt><a href="#swap"> Swapping Rows and Columns (the Swap suite) </a>
</dl>

Decompositions are computed by transforming the elements of a matrix.
Since it is impossible for Jampack to cover all possible
decompositions, the packages has suites implementing the more commonly
used transformations.

<h3><a name="house"></a> Householder Transformations (The House
    suite) </h3>

<p>Back to:
    <a href="00_Manual.html#mancont"> Main contents</a>,
    <a href="11_Trans.html"> Top of section</a>.

<p>A Householder transformation is a unitary
    matrix of the form

<blockquote>
    U = I - uu<sup>H</sup>,
</blockquote>

where u<sup>H</sup>u = 2. The vector u is said to <i>generate</i> the
Householder transformation u.

<p>For any vector x there is a generating vector u such that

<blockquote>
    Ux = se<sub>1</sub>,
</blockquote>

where s is a scalar and e<sub>1</sub> is the vector whose first
component is one and whose other components are zero. Thus the
Householder transformation U introduces zeros into the last components
of x.

<p>If the vector x is embedded in a matrix A, then the Householder
    transformation will introduce zeros into A.
    Specifically, if A has the form

<blockquote>
<pre>
|a a a a a a a|
|a x a a a a a|
|a x a a a a a|
|a x a a a a a|
|a x a a a a a|
|a a a a a a a|
</pre>
</blockquote>
and we embed the matrix U above in an identity matrix
<blockquote>
<pre>
|1 0 0 0 0 0|
|0 u u u u 0|
|0 u u u u 0|
|0 u u u u 0|
|0 u u u u 0|
|0 0 0 0 0 1|
</pre>
</blockquote>
then the product of the two has the form
<blockquote>
<pre>
|1 0 0 0 0 0| |a a a a a a a|   |a a a a a a a|
|0 u u u u 0| |a x a a a a a|   |a s a a a a a|
|0 u u u u 0| |a x a a a a a| = |a 0 a a a a a|
|0 u u u u 0| |a x a a a a a|   |a 0 a a a a a|
|0 u u u u 0| |a x a a a a a|   |a 0 a a a a a|
|0 0 0 0 0 1| |a a a a a a a|   |a a a a a a a|
</pre>
</blockquote>

<p>Similarly a postmultiplication by a Householder transformation
    can introduce zeros into the rows of A.

<p>The House suite contains method to generate and apply
    Householder transformations. There are two methods
    to generate a Householder transformation. The first,

<blockquote>
    public static Z1 genc(Zmat A, int r1, int r2, int c)
</blockquote>

generates a Householder transformation that on premultiplication
introduces zeros into a column of A. Its calling sequence and effect
are illustrated by the following diagram.

<blockquote>
<pre>
      c
      |
   |a a a a a a a|     |a a a a a a|
r1-|a x a a a a a|     |a s a a a a|
   |a x a a a a a|     |a 0 a a a a|
   |a x a a a a a| --> |a 0 a a a a|
r2-|a x a a a a a|     |a 0 a a a a|
   |a a a a a a a|     |a a a a a a|
</pre>
</blockquote>

Here r1, r2, and c specify the part of the matrix from which the
Householder transformation is generated. The elements denoted by x's
are overwritten by the results of the transformation, but the matrix A
is otherwise unaltered. The generating vector is returned as a Z1 of
length r2-r1+1.

<p>The method

<blockquote>
    public static Z1 genr(Zmat A, int r, int c1, int c2)
</blockquote>

generates a Householder transformation that on postmultiplication
introduces zeros into a row of A. Its calling sequence and effect are
illustrated by the following diagram.

<blockquote>
<pre>
     c1    c2  
     |     |
  |a a a a a a|     |a a a a a a|
r-|a x x x x a|     |a s 0 0 0 a|
  |a a a a a a|     |a a a a a a|
  |a a a a a a| --> |a a a a a a|
  |a a a a a a|     |a a a a a a|
  |a a a a a a|     |a a a a a a|
</pre>
</blockquote>

Here r, c2, and c2 specify the part of the matrix from which the
Householder transformation is generated. The elements denoted by x's
are overwritten by the results of the transformation, but the matrix
A is otherwise unaltered. The generating vector is returned
as a Z1 of length c2-c1+1.

<p>A Householder transformation can premultiply or postmultiply a
    matrix. Either operation requires a Z1 work array. Consequently, the
    methods for applying Householder transformations come in two
    varieties: one in which the user furnishes the array and the other in
    which it is generated by the by the method.

<p>The methods

<blockquote>
    public static Zmat ua(Z1 u, Zmat A, int r1, int r2, int c1, int c2, Z1 v)
    <p>
        public static Zmat ua(Z1 u, Zmat A, int r1, int r2, int c1, int c2)
</blockquote>

premultiply the Householder transformation generate by u into
the submatrix of A marked by x's below.

<blockquote>
<pre>
        c1  c2
        |   |
   |a a a a a a|
r1-|a a x x x a|
   |a a x x x a|
   |a a x x x a|
r2-|a a x x x a|
   |a a a a a a|
</pre>
</blockquote>

If r1&gt;r2 or c1&gt;c2, the methods do nothing, which is useful in
handling boundary conditions. The Z1 v must be at least r2-r1+1 in
length. The methods throw a JampackException if u or v are too short.

<p>The methods
<blockquote>
    public static Zmat au(Z1 u, Zmat A, int r1, int r2, int c1, int c2, Z1 v)
    <p>
        public static Zmat au(Z1 u, Zmat A, int r1, int r2, int c1, int c2)
</blockquote>

postmultiply the Householder transformation generate by u into the
submatrix of A illustrated above. If r1&gt;r2 or c1&gt;c2, the
methods do nothing. The Z1 v must be at least c2-c1+1 in length. The
methods throw a JampackException if u or v are too short.

<h3><a name="pivot"></a>Pivoting (the Pivot suite) </h3>

<p>Back to:
    <a href="00_Manual.html#mancont"> Main contents</a>,
    <a href="11_Trans.html"> Top of section</a>.


<p>The Pivot suite contains methods to perform a sequence of
    interchanges to a matrix. The pivot sequence is specified by an
    integer array pvt[], which determines a permutation as follows. Here
    bx is the base index of the matrix in question.

<blockquote>
<pre>
for (k=0; k&lt;pvt.length; k++)
   swap row k+bx and row pvt[k]+bx;
</pre>
</blockquote>


<p> The method for applying pvt to the rows of a is

<blockquote>
    public static Zmat row(Zmat A, int pvt[])
</blockquote>

<p>The suite also contains a method for performing the inverse pivot
    sequence

<blockquote>
<pre>
for(k=pvt.length-1; k&gt;=0; k--)
   swap row k+bx and row pvt[k]+bx;
</pre>
</blockquote>

to the rows of A.

<blockquote>
    public static Zmat rowi(Zmat A, int pvt[])
</blockquote>

Routines for column pivoting will be added later.

<h3><a name="rot"></a> Plane rotations (the Rot suite) </h3>

<p>Back to:
    <a href="00_Manual.html#mancont"> Main contents</a>,
    <a href="11_Trans.html"> Top of section</a>.


<p>The Rot suite generates and applies plane rotations. A 2x2
    plane rotation is a unitary matrix of the form

<blockquote>
<pre>
P = |   c      s|
    |-conj(s)  c|

</pre>
</blockquote>

where c is real and |c|<sup>2</sup>+|s|<sup>2</sup> = 1. The number c
is the cosine of the rotation and the number s is the sine.

<p>Given a 2-vector whose components are x and y, there is plane
    rotation P such that

<blockquote>
<pre>
P|x| =  |   c      s||x| = |z|
 |y|    |-conj(s)  c||y|   |0|
</pre>
</blockquote>

<p> Plane rotations may be premultiplied into a matrix A to combine
    two rows of A. For example, let x, y, c, s, and z be as above, and let

<blockquote>
<pre>
    |1    0     0 0 0|
    |0    c     0 s 0|
P = |0    0     1 0 0|
    |0 -conj(s) 0 c 0|
    |0    0     0 0 0|
</pre>
</blockquote>

Then if

<blockquote>
<pre>
    |a a a a a|
    |a x a a a|
A = |a a a a a|
    |a y a a a|
    |a a a a a|
</pre>
</blockquote>

the matrix PA has the form

<blockquote>
<pre>
    |a a a a a|
    |b z b b b|
B = |a a a a a|
    |b 0 b b b|
    |a a a a a|
</pre>
</blockquote>

The elements denoted by "a" are unchanged by the transformation. Thus
a plane rotation can be used to introduce a zero into a matrix at the
cost of altering two rows of the matrix.

<p>Similarly there is a plane rotation such that

<blockquote>
<pre>
|x y||   c      s||x| = |z 0|
     |-conj(s)  c||y|
</pre>
</blockquote>

If P has the form above and A is of the form

<blockquote>
<pre>
    |a a a a a|
    |a x a y a|
A = |a a a a a|
    |a a a a a|
    |a a a a a|
</pre>
</blockquote>

then B = AP has the form

<blockquote>
<pre>
    |a b a b a|
    |a z a 0 a|
B = |a b a b a|
    |a b a b a|
    |a b a b a|
</pre>
</blockquote>
Thus postmultiplication by a plane rotation can also be used to
introduce zeros into a matrix.

<p>The Rot suite consists of data fields defining a plane rotation and
    static functions to generate and apply the rotations. The defining
    fields are

<blockquote>
    <dl>
        <p>
            <dt> public double c
        <dd> The cosine of the rotation

            <p>
        <dt> public double sr
        <dd> The real part of the sine of the rotation

            <p>
        <dt> public double si
        <dd> The imaginary part of the sine of the rotation

            <p>
        <dt> public double zr
        <dd> The real part of the first component of the transformed vector

            <p>
        <dt> public double si
        <dd> The imaginary part of the first component of the transformed vector
    </dl>
</blockquote>


<p>The methods that generate rotations satisfying

<blockquote>
<pre>
|   c      s||x| = |z|
|-conj(s)  c||y|   |0|
</pre>
</blockquote>

are called genc (c for column). They come in two varieties. One
returns the required Rot. The other initializes a Rot in the calling
sequence. This second variety is necessary to prevent certain
rotation-intensive computations from being dominated by the
generation of new Rots.

<blockquote>
    <dl>
        <p>
            <dt> public static Rot
                genc(double xr, double xi, double yr, double yi) <br>
                public static void
                genc(double xr, double xi, double yr, double y, Rot P)
        <dd> Generates a rotation from the complex numbers
            x = xr+i*xi and y = yr+i*yi.

            <p>
        <dt> public static Rot genc(double x, double y) <br>
            public static void genc(, double x, double y, Rot P)
        <dd> Generates a real rotation from x and y.

            <p>
        <dt> public static Rot genc(Zmat A, int i1, int i2, int j) <br>
            public static void genc(Zmat A, int i1, int i2, intj, Rot P)
        <dd> Generates a rotation from the elements
            x=a<sub>i1,j</sub> and y=a<sub>i2,j</sub>. The element
            a<sub>i1,j</sub> is overwritten by z and a<sub>i2,j</sub>
            is overwritten by zero.
    </dl>
</blockquote>

The methods that generate rotations satisfying

<blockquote>
<pre>
|x y||   c      s||x| = |z 0|
     |-conj(s)  c||y|
</pre>
</blockquote>

are called genr. They also come in pairs.

<blockquote>
    <dl>
        <p>
            <dt> public static Rot
                genr(double xr, double xi, double yr, double yi) <br>
                public static void
                genr(double xr, double xi, double yr, double yi, Rot P)
        <dd> Generates a rotation from the numbers x = xr+i*xi
            and y = yr+i*xi.

            <p>
        <dt> public static Rot genr(double x, double y) <br>
            public static void genr(double x, double y, Rot P)
        <dd> Generates a real rotation from x and y.

            <p>
        <dt> public static Rot genr(Zmat A, int i, int j1, int j2) <br>
            public static void genr(Zmat A, int i, int j1, int j2, Rot P)
        <dd> Generates a rotation from the elements x=a<sub>i,j1</sub>
            and y=a<sub>i,j2</sub>. The element a<sub>i,j1</sub>
            is overwritten by z and a<sub>i,j2</sub> is overwritten by zero.

    </dl>
</blockquote>

There are four methods to apply a rotation to a matrix.

<blockquote>
    <dl>
        <p>
            <dt> public static void
                pa(Rot P, Zmat A, int i1, int i2, int j1, int j2)
        <dd> Multiplies rows (i1,j1:j2) and (i2,j1:j2)
            of A by P.

            <p>
        <dt> public static void
            pha(Rot P, Zmat A, int i1, int i2, int j1, int j2)
        <dd> Multiplies rows (i1,j1:j2) and (i2,j1:j2)
            of A by P<sup>H</sup>.

            <p>
        <dt> public static void
            ap(Zmat A, Rot P, int i1, int i2, int j1, int j2)
        <dd> Multiplies columns (i1:i2,j1) and A(i2:i2,j1)
            of A by P.

            <p>
        <dt> public static void
            aph(Zmat A, Rot P, int i1, int i2, int j1, int j2)
        <dd> Multiplies columns (i1:i2,j1) and A(i2:i2,j1)
            of A by P<sup>H</sup>.
    </dl>
</blockquote>

<h3><a name="swap"></a> Swapping Rows and Columns (the Swap suite) </h3>

<p>Back to:
    <a href="00_Manual.html#mancont"> Main contents</a>,
    <a href="11_Trans.html"> Top of section</a>.


<p>The Swap suite has two routines for swapping rows or columns of
    a matrix.

<blockquote>
    <dl>
        <p>
            <dt> public static void rows(Zmat A, int r1, int r2)
        <dd> Interchanges rows r1 and r2 of A. <br>
            Throws JampackException if r1 or r2 is out of
            range.

            <p>
        <dt> public static void cols(Zmat A, int c1, int c2)
        <dd> Interchanges columns c1 and c2 of A. <br>
            Throws JampackException of c1 or c2 is out of
            range.
    </dl>
</blockquote>